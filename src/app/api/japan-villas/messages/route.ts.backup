import { NextResponse } from "next/server";
import { readFile } from "fs/promises";
import { join } from "path";

// Property mapping for Beds24 property IDs
const PROPERTY_MAPPING = {
  265980: "LAKE HOUSE é‡å°»æ¹–",
  265981: "MOUNTAIN VILLA ãƒ‹ã‚»ã‚³", 
  281224: "The Lake Side INN"
};

interface Beds24Message {
  id: number;
  authorOwnerId: number | null;
  bookingId: number;
  roomId: number;
  propertyId: number;
  message: string;
  time: string;
  source: string;
  read: boolean;
}

interface Beds24Booking {
  bookingId: number;
  propId?: number;
  propertyId?: number;
  guestFirstName?: string;
  guestName?: string;
  guestSurname?: string;
  referer?: string;
}

async function getConciergeState() {
  try {
    const statePath = join(process.env.OPENCLAW_WORKSPACE || '/Users/sekaichi/.openclaw/workspace', 'japan-villas', 'concierge-state.json');
    const stateContent = await readFile(statePath, 'utf-8');
    const state = JSON.parse(stateContent);
    return {
      lastCheckedMessageId: state.lastCheckedMessageId || 0,
      processedMessageIds: state.processedMessageIds || []
    };
  } catch (error) {
    console.warn('Could not read concierge state:', error);
    return {
      lastCheckedMessageId: 0,
      processedMessageIds: []
    };
  }
}

async function fetchBeds24Messages(): Promise<any[]> {
  try {
    const token = process.env.BEDS24_API_TOKEN;
    if (!token || token === 'your_beds24_token_here') {
      console.warn('Beds24 API token not configured, returning mock data');
      return getMockMessages();
    }

    // Get concierge state to know which messages are processed
    const conciergeState = await getConciergeState();

    // Fetch messages
    const messagesResponse = await fetch('https://api.beds24.com/v2/bookings/messages?limit=50', {
      headers: {
        'token': token
      }
    });

    if (!messagesResponse.ok) {
      throw new Error(`Beds24 API error: ${messagesResponse.status}`);
    }

    const rawMessages = await messagesResponse.json();
    
    // Handle Beds24 API response structure
    let messages: Beds24Message[] = [];
    if (rawMessages && Array.isArray(rawMessages.data)) {
      messages = rawMessages.data;
    } else if (Array.isArray(rawMessages)) {
      messages = rawMessages;
    } else {
      console.warn('Unexpected Beds24 API response structure:', rawMessages);
      throw new Error('Invalid API response structure');
    }
    
    // Filter for guest messages only
    const guestMessages = messages.filter(msg => msg.source === 'guest');

    // Get booking details for each message to get guest names and property info
    const enrichedMessages = await Promise.all(
      guestMessages.map(async (message) => {
        try {
          const bookingResponse = await fetch(`https://api.beds24.com/v2/bookings/${message.bookingId}`, {
            headers: { 'token': token }
          });
          
          if (bookingResponse.ok) {
            const booking: Beds24Booking = await bookingResponse.json();
            const propertyId = message.propertyId || booking.propertyId || booking.propId;
            const propertyName = PROPERTY_MAPPING[propertyId] || `Property ${propertyId}`;
            const platform = booking.referer?.includes('airbnb') ? 'Airbnb' : 
                           booking.referer?.includes('booking') ? 'Booking.com' : 
                           'Direct';

            // Determine if message is new or processed
            const isProcessed = conciergeState.processedMessageIds.includes(message.id);
            const isNew = message.id > conciergeState.lastCheckedMessageId;

            return {
              id: `beds24-${message.id}`,
              guestName: booking.guestName || booking.guestFirstName || 'Guest',
              property: propertyName,
              platform,
              message: message.message,
              timestamp: message.time,
              direction: 'inbound' as const,
              status: isProcessed ? 'replied' as const : (isNew ? 'pending' as const : 'pending' as const),
              bookingRef: `${booking.bookingId}`,
              suggestedReply: `Thank you for your message. We'll get back to you shortly!`,
              isNew: isNew && !isProcessed
            };
          }
        } catch (error) {
          console.warn('Failed to fetch booking details:', error);
        }

        // Fallback if booking details failed
        const isProcessed = conciergeState.processedMessageIds.includes(message.id);
        const isNew = message.id > conciergeState.lastCheckedMessageId;
        const propertyName = PROPERTY_MAPPING[message.propertyId] || `Property ${message.propertyId}`;
        
        return {
          id: `beds24-${message.id}`,
          guestName: 'Guest',
          property: propertyName,
          platform: 'Beds24',
          message: message.message,
          timestamp: message.time,
          direction: 'inbound' as const,
          status: isProcessed ? 'replied' as const : 'pending' as const,
          bookingRef: `${message.bookingId}`,
          suggestedReply: `Thank you for your message. We'll get back to you shortly!`,
          isNew: isNew && !isProcessed
        };
      })
    );

    // Sort by timestamp, newest first
    return enrichedMessages.sort((a, b) => 
      new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()
    );

  } catch (error) {
    console.error('Error fetching Beds24 messages:', error);
    return getMockMessages();
  }
}

function getMockMessages() {
  return [
    {
      id: "msg-001",
      guestName: "ç”°ä¸­å¤ªéƒ",
      property: "LAKE HOUSE é‡å°»æ¹–",
      platform: "Airbnb",
      message: "ãƒã‚§ãƒƒã‚¯ã‚¤ãƒ³ã®æ™‚é–“ã‚’30åˆ†æ—©ã‚ã‚‰ã‚Œã¾ã™ã‹ï¼Ÿ15:00å‰ã«åˆ°ç€äºˆå®šã§ã™ã€‚",
      timestamp: "2026-02-20T14:30:00Z",
      direction: "inbound",
      status: "pending",
      bookingRef: "HMA8XXXXX",
      suggestedReply: `ç”°ä¸­æ§˜ã€ãŠç–²ã‚Œæ§˜ã§ã™ã€‚15:00ã®ã‚¢ãƒ¼ãƒªãƒ¼ãƒã‚§ãƒƒã‚¯ã‚¤ãƒ³ã¯å¯èƒ½ã§ã™ã€‚æ¸…æƒãŒ14:30é ƒã«å®Œäº†äºˆå®šã§ã™ã®ã§ã€15:00ã«ãŠè¶Šã—ãã ã•ã„ã€‚éµã¯ã‚­ãƒ¼ãƒœãƒƒã‚¯ã‚¹ï¼ˆã‚³ãƒ¼ãƒ‰${process.env.LAKEHOUSE_KEYBOX_CODE || "XXXX"}ï¼‰ã‹ã‚‰ãŠå–ã‚Šã„ãŸã ã‘ã¾ã™ã€‚ã”åˆ°ç€ã‚’ãŠå¾…ã¡ã—ã¦ãŠã‚Šã¾ã™ï¼`,
    },
    {
      id: "msg-002", 
      guestName: "Sarah Johnson",
      property: "MOUNTAIN VILLA ãƒ‹ã‚»ã‚³",
      platform: "Airbnb",
      message: "Hi! We're arriving tomorrow. Is there grocery delivery available or should we stop at a supermarket on the way?",
      timestamp: "2026-02-20T13:15:00Z",
      direction: "inbound",
      status: "replied",
      bookingRef: "HMA8YYYYY",
      reply: "Hello Sarah! Welcome! There's an excellent supermarket called MaxValu about 10 minutes from the villa. I'd recommend stopping there on your way. They have a great selection including local Hokkaido specialties. Would you like me to send you the Google Maps link?",
    },
    {
      id: "msg-003",
      guestName: "Michael Chen", 
      property: "The Lake Side INN",
      platform: "Booking.com",
      message: "What's the WiFi password? I can't find it in the guidebook.",
      timestamp: "2026-02-20T11:00:00Z",
      direction: "inbound",
      status: "pending",
      bookingRef: "BDC-12345",
      suggestedReply: `Hi Michael! The WiFi information for your cabin is: Network: "NojiriLake-1" Password: "${process.env.LAKESIDE_CABIN1_WIFI || "[REDACTED]"}" You'll find this network listed on your device. If you have any trouble connecting, please let me know! Enjoy your stay at The Lake Side INN. ğŸï¸`,
    }
  ];
}

export async function GET() {
  const messages = await fetchBeds24Messages();
  return NextResponse.json(messages);
}

export async function POST(request: Request) {
  const body = await request.json();
  const { messageId, reply } = body;
  
  if (!messageId || !reply) {
    return NextResponse.json(
      { ok: false, error: "messageId and reply are required" },
      { status: 400 }
    );
  }

  try {
    // TODO: Implement actual reply sending via Beds24 API
    // For now, just acknowledge the reply was received
    console.log(`Reply to message ${messageId}: ${reply}`);
    
    return NextResponse.json({ 
      ok: true, 
      message: "Reply queued for sending" 
    });
  } catch (error) {
    console.error('Error sending reply:', error);
    return NextResponse.json(
      { ok: false, error: "Failed to send reply" },
      { status: 500 }
    );
  }
}